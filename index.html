<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Scrolling Runner Game for Kids</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <style>
    /* General body and canvas styles */
    body {
      margin: 0;
      overflow: hidden;
      background: #a3d2ca; /* a soft, friendly teal */
      font-family: 'Comic Sans MS', cursive, sans-serif;
    }
    #gameCanvas {
      display: block;
      background: #f7f7f7;
    }
    /* Ad overlay styles */
    #adOverlay {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: rgba(0, 0, 0, 0.8);
      color: white;
      font-size: 2em;
      display: none;
      justify-content: center;
      align-items: center;
      flex-direction: column;
      z-index: 10;
    }
    #adOverlay p {
      margin: 10px;
    }
  </style>
</head>
<body>
  <canvas id="gameCanvas"></canvas>
  <div id="adOverlay">
    <p>Advertisement</p>
    <p id="adTimer">30</p>
  </div>
  <script>
    "use strict";
    
    // Get canvas and context, and set canvas dimensions.
    const canvas = document.getElementById("gameCanvas");
    const ctx = canvas.getContext("2d");
    canvas.width = window.innerWidth;
    canvas.height = window.innerHeight;
    
    // Game state variables.
    let gameState = "running"; // "running" or "ad"
    let score = 0;
    let level = 1;
    const levelThreshold = 100;  // Increase level every 100 points.
    
    // Player object.
    const player = {
      x: 50,
      y: canvas.height - 150,
      width: 50,
      height: 50,
      vy: 0,
      jumpForce: -15,
      gravity: 0.8,
      onGround: true
    };
    
    // Array to store obstacles.
    let obstacles = [];
    let obstacleSpawnTimer = 0;
    let obstacleSpawnInterval = 2000; // milliseconds
    let obstacleSpeed = 5;
    
    // Ad overlay variables.
    const adOverlay = document.getElementById("adOverlay");
    const adTimerDisplay = document.getElementById("adTimer");
    let adTimeRemaining = 30;
    let adInterval;
    
    // Audio: use a free click sound from Google's Actions Sounds.
    const clickSound = new Audio("https://actions.google.com/sounds/v1/cartoon/clang_and_wobble.ogg");
    clickSound.preload = "auto";
    
    // Handle keyboard for jump (Spacebar).
    document.addEventListener("keydown", function(e) {
      if (e.code === "Space" && player.onGround && gameState === "running") {
        player.vy = player.jumpForce;
        player.onGround = false;
      }
    });
    
    // Function to spawn obstacles.
    function spawnObstacle() {
      const obsHeight = 50 + Math.random() * 50; // between 50 and 100 px
      const obsWidth = 30 + Math.random() * 20;  // between 30 and 50 px
      const obstacle = {
        x: canvas.width,
        y: canvas.height - 50 - obsHeight,
        width: obsWidth,
        height: obsHeight
      };
      obstacles.push(obstacle);
    }
    
    // Function to update game logic.
    function update(deltaTime) {
      if (gameState === "running") {
        // Increase score based on time elapsed.
        score += deltaTime * 0.01;
        
        // Check for level up.
        if (score >= level * levelThreshold) {
          level++;
          gameState = "ad";
          startAdCountdown();
        }
        
        // Update player physics.
        player.vy += player.gravity;
        player.y += player.vy;
        if (player.y + player.height >= canvas.height - 50) {
          player.y = canvas.height - 50 - player.height;
          player.vy = 0;
          player.onGround = true;
        }
        
        // Update obstacle spawn timer.
        obstacleSpawnTimer += deltaTime;
        if (obstacleSpawnTimer >= obstacleSpawnInterval) {
          spawnObstacle();
          obstacleSpawnTimer = 0;
        }
        
        // Update obstacles.
        for (let i = obstacles.length - 1; i >= 0; i--) {
          obstacles[i].x -= obstacleSpeed;
          // Remove obstacles that have left the screen.
          if (obstacles[i].x + obstacles[i].width < 0) {
            obstacles.splice(i, 1);
          }
          // Check collision with player.
          if (rectIntersect(player, obstacles[i])) {
            resetGame();
          }
        }
      }
    }
    
    // Function to render the game.
    function render() {
      // Clear the canvas.
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      
      // Draw background.
      ctx.fillStyle = "#a3d2ca";
      ctx.fillRect(0, 0, canvas.width, canvas.height);
      
      // Draw ground.
      ctx.fillStyle = "#f7f7f7";
      ctx.fillRect(0, canvas.height - 50, canvas.width, 50);
      
      // Draw player (using a placeholder image-like rectangle).
      ctx.fillStyle = "#ff6f69";
      ctx.fillRect(player.x, player.y, player.width, player.height);
      
      // Draw obstacles.
      ctx.fillStyle = "#88d8b0";
      obstacles.forEach(obs => {
        ctx.fillRect(obs.x, obs.y, obs.width, obs.height);
      });
      
      // Draw score and level.
      ctx.fillStyle = "#424242";
      ctx.font = "24px Arial";
      ctx.fillText("Score: " + Math.floor(score), 20, 30);
      ctx.fillText("Level: " + level, 20, 60);
    }
    
    // Collision detection between rectangles.
    function rectIntersect(r1, r2) {
      return !(r2.x > r1.x + r1.width ||
               r2.x + r2.width < r1.x ||
               r2.y > r1.y + r1.height ||
               r2.y + r2.height < r1.y);
    }
    
    // Reset game state on collision.
    function resetGame() {
      score = 0;
      level = 1;
      obstacles = [];
      player.y = canvas.height - 150;
      player.vy = 0;
    }
    
    // Ad overlay: display ad for 30 seconds after a level is reached.
    function startAdCountdown() {
      adTimeRemaining = 30;
      adOverlay.style.display = "flex";
      adTimerDisplay.textContent = adTimeRemaining;
      adInterval = setInterval(() => {
        adTimeRemaining--;
        adTimerDisplay.textContent = adTimeRemaining;
        if (adTimeRemaining <= 0) {
          clearInterval(adInterval);
          adOverlay.style.display = "none";
          // Increase difficulty for the next level.
          obstacleSpeed += 1;
          if (obstacleSpawnInterval > 500) {
            obstacleSpawnInterval -= 200;
          }
          gameState = "running";
        }
      }, 1000);
    }
    
    // Main game loop using requestAnimationFrame.
    let lastTime = 0;
    function gameLoop(timestamp) {
      const deltaTime = timestamp - lastTime;
      lastTime = timestamp;
      update(deltaTime);
      render();
      requestAnimationFrame(gameLoop);
    }
    requestAnimationFrame(gameLoop);
  </script>
</body>
</html>
